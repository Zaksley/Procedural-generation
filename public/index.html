<!DOCTYPE html>
<html>
<head>
  <meta charset="utf8"/>
  <title>Procedural Textures (Equipe 12830)</title>
  <meta name="author" content="Mathieu Brassart,Enzo Médina,Léna Herau,Killian Dieu"/>
</head>

<style>
body {
	font-family:arial;
	width:100vw;
	height:calc(100vh + 8px);
	overflow:hidden;
	display:grid;
	grid-template-columns:30% 1fr;
	margin-top:-8px;
	margin-left:-8px
}
p {
	font-size:18px;
}
input[type=range]{
	-webkit-appearance: none; 
  	appearance: none;
  	width: 100%;
  	height: 10px;
  	background: #AAA;
  	outline: none;
  	border-radius:10px;
  	opacity: 0.7;
  	-webkit-transition: .2s;
  	transition: opacity .2s;
}
input[type=range]:hover {
	opacity:1;
}
input[type=range]::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 20px;
  height: 20px;
  background: black;
  cursor: pointer;
}
input[type=range]::-moz-range-thumb {
  width: 20px;
  height: 20px;
  background: black;
  cursor: pointer;
  border-radius:30%;
  border:0;
}
input[type=color] {
	margin-left:18px;
}
textarea {
	background-color:white;
	width:calc(100% - 24px);
	padding:12px;
	resize:none;
	font-size:1.2em;
}
#treebutton {
	/*width:calc(100% + 2px);*/
	padding:4px;
	font-size:1.1em;
	margin-top:12px;
	float:right;
}
</style>

<body>

	<div style="grid-column: 1 / 2;padding:32px;background-color:#DDD;border-right:1px solid #AAA; overflow-y:auto;">
		
		<!-- ========= Sliders & parameters ======== -->
		<h2>Base texture :</h2>

		<label for="texture">Select a texture : </label>

		<script>
			// Global vars
			let DATA = [], BASEDATA = [];
			let TEXTURE = "";
			let FILTER = "filter_resize";
			let DICT = {};
			let OPTDICT = {intensity:1, translation:0};
			let XOFFSET = 0, YOFFSET = 0;
		</script>

		<select name="texture" id="textureName" oninput="showTextureOptions(this.value)">
			<option selected>No texture selected</option>
			<optgroup label="Specific Textures">
				<option value="solid">Solid color</option>
				<option value="horizontalGradient">Color gradients</option>
				<option value="star">Star pattern</option>
				<option value="regularShape">Polygon pattern</option>
			</optgroup>
			<optgroup label="Regular Tilings">
				<option value="triangleTiling">Triangular tiling</option>
				<option value="hexagonTiling">Hexagonal tiling</option>
			</optgroup>
			<optgroup label="Semi-Regular Tilings">
				<option value="3Dcube">Isometric cubic tiling</option>
				<option value="3DgambarTiling">Gambar tiling</option>
				<option value="elongatedTriangular">Elongated triangular tiling</option>
				<option value="snubSquare">Snub square tiling</option>
				<option value="snubHexagonal">Snub hexagonal tiling</option>
				<option value="truncatedSquare">Truncated square tiling</option>
				<option value="truncatedHexagon">Truncated hexagon tiling</option>
				<option value="smallRhombitrihexagonalTiling">Small rhombitrihexagonal tiling</option>
				<option value="bigRhombitrihexagonalTiling">Big rhombitrihexagonal tiling</option>
				<option value="trihexagonal">Trihexagonal tiling</option>
			</optgroup>
			<optgroup label="Non-regular Tilings">
				<option value="squareTiling">Checkboard</option>
				<option value="caireTiling">Pentagonal tiling</option>
				<option value="pentagonTiling3">Rotating pentagonal tiling</option>
				<!-- PentagonTiling 4 : not yet fixed (offset issue) -->
				<option value="pentagonTiling4" disabled>PentagonTiling4</option>
			</optgroup>
			<optgroup label="Noise maps">
				<option value="whiteNoise">White noise</option>
				<option value="limitedWhiteNoise">Limited white noise</option>
				<!-- Perlin Noise : todo add support for unlimited colors -->
				<option value="perlinNoise" disabled>Perlin noise</option>
			</optgroup>
			<optgroup label="Diagrams & Fractals">
				<option value="Voronoi">Voronoï diagram</option>
				<option value="squareFractal">Square fractal</option>
				<option value="triangularFractal">Triangular fractal</option>
			</optgroup>
            <optgroup label="Cellular Automata">
                    <option value="forestFire">Forest Fire</option>
                    <option value="gameOfLife">Conway's Game Of Life</option>
            </optgroup>
            <optgroup label="Animations">
				<option disabled>Todo</option>
			</optgroup>
		</select><br><br>

		<!-- SIZE -->
		<div class="textureOption size" style="display:none">
			<p>Pattern size : <b id="size">80</b></p>
			<input type="range" min="10" max="100" value="80" oninput="updateSliderValue('size', this.value)"
			onchange="DICT['size'] = parseInt(this.value); regenerateImage();">
		</div>

		<!-- SIZE 2 -->
		<div class="textureOption size2" style="display:none">
			<p>Pattern second size : <b id="size2">80</b></p>
			<input type="range" min="10" max="100" value="80" oninput="updateSliderValue('size2', this.value)"
			onchange="DICT['size2'] = parseInt(this.value); regenerateImage();">
		</div>

		<!-- COLUMNS -->
		<div class="textureOption columns" style="display:none">
			<p>Columns : <b id="columns">3</b></p>
			<input type="range" min="1" max="40" value="3" oninput="updateSliderValue('columns', this.value)"
			onchange="DICT['columns'] = parseInt(this.value); regenerateImage();">
		</div>

		<!-- ROWS -->
		<div class="textureOption rows" style="display:none">
			<p>Rows : <b id="rows">3</b></p>
			<input type="range" min="1" max="40" value="3" oninput="updateSliderValue('rows', this.value)"
			onchange="DICT['rows'] = parseInt(this.value); regenerateImage();">
		</div>

		<!-- TREE PROBABILITY -->
		<div class="textureOption treeP" style="display:none">
			<p>Tree Probability : <b id="treeP">50</b></p>
			<input type="range" min="5" max="95" value="50" oninput="updateSliderValue('treeP', this.value)"
			onchange="DICT['treeP'] = parseInt(this.value); regenerateImage();">
		</div>

		<!-- LIGHTNING PROBABILITY -->
		<div class="textureOption lightP" style="display:none">
			<p>Lightning Probability : <b id="lightP">5</b></p>
			<input type="range" min="5" max="95" value="5" oninput="updateSliderValue('lightP', this.value)"
			onchange="DICT['lightP'] = parseInt(this.value); regenerateImage();">
		</div>

		<!-- STEP NUMBER -->
		<div class="textureOption step" style="display:none">
			<p>Step : <b id="step">30</b></p>
			<input type="range" min="1" max="100" value="30" oninput="updateSliderValue('step', this.value)"
			onchange="DICT['step'] = parseInt(this.value); regenerateImage();">
		</div>

		<!-- GERMS -->
		<div class="textureOption germs" style="display:none">
			<p>Germs : <b id="germs">10</b></p>
			<input type="range" min="1" max="40" value="10" oninput="updateSliderValue('germs', this.value)"
			onchange="DICT['germs'] = parseInt(this.value); regenerateImage();">
		</div>
                
		<!-- ANGLE -->
		<div class="textureOption angle" style="display:none">
			<p>Angle : <b id="angle">135</b>°</p>
			<input type="range" min="90" max="180" value="135" oninput="updateSliderValue('angle', this.value)"
			onchange="DICT['angle'] = parseInt(this.value); regenerateImage();">
		</div>

		<!-- BRANCHES -->
		<div class="textureOption branches" style="display:none">
			<p>Branches : <b id="branches">5</b></p>
			<input type="range" min="3" max="20" value="5" oninput="updateSliderValue('branches', this.value)"
			onchange="DICT['branches'] = parseInt(this.value); regenerateImage();">
		</div>

		<!-- FRACTAL DEPTH -->
		<div class="textureOption depth" style="display:none">
			<p>Depth levels : <b id="depth">3</b></p>
			<input type="range" min="1" max="8" value="3" oninput="updateSliderValue('depth', this.value)"
			onchange="DICT['depth'] = parseInt(this.value); regenerateImage();">
		</div>

		<!-- CENTER X -->
		<div class="textureOption centerx" style="display:none">
			<p>Horizontal centering : <b id="centerx">250</b></p>
			<input type="range" min="0" max="50" value="25" oninput="updateSliderValue('centerx', this.value*10/WIDTH)"
			onchange="DICT['centerx'] = parseInt(this.value)*10; regenerateImage();">
		</div>

		<!-- CENTER Y -->
		<div class="textureOption centery" style="display:none">
			<p>Vertical centering : <b id="centery">0.5</b></p>
			<input type="range" min="0" max="50" value="25" oninput="updateSliderValue('centery', this.value*10/HEIGHT)"
			onchange="DICT['centery'] = parseInt(this.value)*10; regenerateImage();">
		</div>

		<!-- COLOR 1 -->
		<div class="textureOption color1" style="display:none">
			<p>Color 1 : <b id="color1">#0080FF</b>
			<input type="color" value="#0080FF" oninput="updateSliderValue('color1', this.value)"
			onchange="DICT['color1'] = hexaToRGBA(this.value); regenerateImage();">
			</p>
		</div>

		<!-- COLOR 2 -->
		<div class="textureOption color2" style="display:none">
			<p>Color 2 : <b id="color2">#0000FF</b>
			<input type="color" value="#0000FF" oninput="updateSliderValue('color2', this.value)"
			onchange="DICT['color2'] = hexaToRGBA(this.value); this.value; regenerateImage();">
			</p>
		</div>

		<!-- COLOR 3 -->
		<div class="textureOption color3" style="display:none">
			<p>Color 3 : <b id="color3">#ff8000</b>
			<input type="color" value="#ff8000" oninput="updateSliderValue('color3', this.value)"
			onchange="DICT['color3'] = hexaToRGBA(this.value); this.value; regenerateImage();">
			</p>
		</div>

		<!-- COLOR 4 -->
		<div class="textureOption color4" style="display:none">
			<p>Color 4 : <b id="color4">#ef76ff</b>
			<input type="color" value="#ef76ff" oninput="updateSliderValue('color4', this.value)"
			onchange="DICT['color4'] = hexaToRGBA(this.value); this.value; regenerateImage();">
			</p>
		</div>

		<!-- ======= -->

		<hr style="margin-top:18px;opacity:0">

		<h2>Display options :</h2>

		<!-- ZOOM -->
		<div class="filterOption zoom" style="display:block">
			<p>Zoom : <b id="zoom">1</b>00%</p>
			<input type="range" min="1" max="10" value="1" oninput="updateSliderValue('zoom', this.value)"
			onchange="OPTDICT['intensity'] = parseInt(this.value); regenerateFilters();">
		</div>

		<!-- TRANSLATION X -->
		<div class="filterOption xoffset" style="display:block">
			<p>X-Offset : <b id="xoffset">0</b>px (<b id="xoffsetprc">0</b>%)</p>
			<input type="range" min="0" max="500" value="0" oninput="updateSliderValue('xoffset', this.value); updateSliderValue('xoffsetprc', this.value*100/WIDTH);"
			onchange="XOFFSET = parseInt(this.value); regenerateFilters();">
		</div>

		<!-- TRANSLATION Y -->
		<div class="filterOption yoffset" style="display:block">
			<p>Y-Offset : <b id="yoffset">0</b>px (<b id="yoffsetprc">0</b>%)</p>
			<input type="range" min="0" max="500" value="0" oninput="updateSliderValue('yoffset', this.value); updateSliderValue('yoffsetprc', this.value*100/HEIGHT);"
			onchange="YOFFSET = parseInt(this.value); regenerateFilters();">
		</div>

		<!-- <input type="button" id="regeneratebutton" onclick="regenerateImage(); regenerateFilters();" value="Regenerate with those options"><br><br><br> -->

		<!-- ======= -->

		<!-- =============== JSON DOC ============== -->

		<hr style="margin-top:18px;opacity:0">

		<h2>Tree generator :</h2>
		<textarea placeholder="DO NOT USE YET&#x0a;'property': {&#x0a;&#x09;'subproperty':'value',&#x0a;&#x09;'subproperty_2':'value2'&#x0a;}" id="textarea" rows="10" spellcheck="false"></textarea>
		<input type="button" id="treebutton" onclick="generateImageFromJson();" value="Generate image"><br><br><br>

		<p id="jsonerror" style="display:none;color:red"></p>

		<br style="margin-top:40px">

	</div>

	<div style="grid-column: 2 / 3;overflow-y: auto;overflow-x: hidden;padding-right:32px">
		<!-- ================ Canvas =============== -->

		<h2 style="margin-left:32px;margin-top:32px">Procedural textures</h2>
		<canvas id="canvas" style="border:1px solid black;margin:32px;"></canvas>

	</div>


</body>

<script src="../src/filters.js"></script>
<script src="../src/textures.js"></script>
<script src="../src/animations.js"></script>
<script src="../src/main.js"></script>

<script>

	// Updates the image displayed (with current canvas, texture & dictionnary)
	function regenerateImage(){
		BASEDATA = generateTexture(CANVAS, window[TEXTURE](DICT));
		generateImage(CANVAS, BASEDATA);
	};

	// Updates the image displayed with the display filters
	function regenerateFilters(){
		BASEDATA = generateTexture(CANVAS, window[TEXTURE](DICT), XOFFSET, YOFFSET);
		DATA = option_resize(OPTDICT)(BASEDATA);
		generateImage(CANVAS, DATA);
	};

	// Changes the label number to match the slider value 
	function updateSliderValue(sliderValueId, value){
		document.getElementById(sliderValueId).innerHTML = value;
	};

	// Converts a hexa string (#[0-9A-Fa-f]{6}) to a rgba array 
	function hexaToRGBA(hexa){
		let rgb = [hexa.substr(1,2),hexa.substr(3,2),hexa.substr(5,2)];
		rgba = rgb.map((e) => parseInt(e.substr(0,1), 16)*16 + parseInt(e.substr(1,1), 16));
		rgba.push(255);
		return rgba;
	};

	// Generates image from the textarea
	function generateImageFromJson(){
		// Parsing
		let data = '{' + document.getElementById("textarea").value + '}';
		let jsondata = {};
		let error = false;
		try {
			JSON.parse(data);
		} catch (e) {
			error = true;
			document.getElementById('jsonerror').innerHTML = "Parsing error: " + e;
			document.getElementById('jsonerror').style.display = "block";
		} finally {
			if(error === false) {
				jsondata = JSON.parse(data);
				document.getElementById('jsonerror').style.display = "none";
			} else {
				return;
			}
		}

		// Transformation
		// TODO

		// Image generation
		// TODO
		console.log(jsondata);
	}

	// TODO : add animation support
	function showTextureOptions(value){
		TEXTURE = "texture_" + value;
		console.log("Switching to " + value + " texture ...");
		// Generating default texture
		regenerateImage();

		// Gathering options
		let options = [];
		switch(value){
			// General
				case "solid": 				options = ["color1"]; break;
				case "horizontalGradient": 	options = ["columns", "color1", "color2"]; break;
				case "star": 				options = ["size", "branches", "centerx", "centery", "color1", "color2"]; break;
				case "regularShape": 		options = ["size", "branches", "centerx", "centery", "color1", "color2"]; break;
			// Regular tilings
				case "triangleTiling": 		options = ["size", "color1", "color2"]; break;
				case "hexagonTiling": 		options = ["size", "color1", "color2", "color3"]; break;
			// Semi-regular tilings
				case "3Dcube": 				options = ["size", "color1", "color2", "color3"]; break;
				case "3DgambarTiling": 		options = ["size", "color1", "color2", "color3"]; break;
				case "elongatedTriangular": options = ["size", "color1", "color2", "color3", "color4"]; break;
				case "snubSquare": 			options = ["size", "color1", "color2", "color3"]; break;
				case "snubHexagonal": 		options = ["size", "color1", "color2", "color3"]; break;
				case "truncatedSquare": 	options = ["size", "color1", "color2", "color3"]; break;
				case "truncatedHexagon": 	options = ["size", "color1", "color2", "color3", "color4"]; break;
				case "3DgambarTiling": 		options = ["size", "color1", "color2", "color3"]; break;
				case "smallRhombitrihexagonalTiling": 	options = ["size", "color1", "color2", "color3"]; break;
				case "bigRhombitrihexagonalTiling": 	options = ["size", "color1", "color2", "color3"]; break;
				case "trihexagonal": 		options = ["size", "color1", "color2"]; break;
			// Non-regular tilings
				case "squareTiling": 		options = ["rows", "columns"]; break;
				case "caireTiling": 		options = ["size", "angle", "color1", "color2", "color3", "color4"]; break;
				case "pentagonTiling3":		options = ["size", "angle", "color1", "color2", "color3"]; break;
				case "pentagonTiling4":		options = ["size", "size2", "angle", "color1", "color2", "color3", "color4"]; break;
            // Noise maps todo
                case "limitedWhiteNoise": 	options = ["rows", "columns"]; break;
            // Diagrams todo
            	case "Voronoi":             options = ["germs"]; break;
            	case "squareFractal":    	options = ["depth", "color1", "color2"]; break;
            	case "triangularFractal":   options = ["depth", "color1"]; break;
            // Cellular Automata
                case "forestFire":          options = ["treeP", "lightP", "step"]; break;
                case "gameOfLife":          options = ["step"]; break;
			// Animations todo

			default: 					options = []; break;
		};

		// Displaying options
		Array.from(document.getElementsByClassName("textureOption")).forEach(function(e, i){
			e.style.display = "none";
		});
		options.forEach(function(e, i){
			document.getElementsByClassName(e)[0].style.display = "block";
		});
	};

	// Prevents usage of TAB to exit the textarea, indent code instead
	// Todo add shift+tab ?
	document.getElementById("textarea").addEventListener('keydown', function(e) {
		if(e.key == 'Tab') {
			e.preventDefault();
			let start = this.selectionStart;
			let end = this.selectionEnd;

			// Indent whole block of code
			let linesBetween = this.value.substring(start, end).split('\n');
			let newBlock = "";
			for(let i = 0; i < linesBetween.length; i++) {
				if(i > 0) newBlock += '\n';
				newBlock += "\t" + linesBetween[i];
			};

			// Updates value
			this.value = this.value.substring(0, start) 
				+ newBlock 
				+ this.value.substring(end);

			// Moves cursor
			this.selectionStart = start + 1;
			this.selectionEnd = end + linesBetween.length;
		};
	});

</script>

</html>
